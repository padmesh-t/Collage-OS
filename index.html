<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>C Project – Interactive Terminal</title>
<style>
  body {
    background: #0b0b0b;
    color: #00ffae;
    font-family: "Fira Code", monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }
  h1 {
    color: #00ffae;
  }
  .desc {
    max-width: 800px;
    background: #151515;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
  }
  select, button {
    background: #00ffae;
    color: #000;
    border: none;
    padding: 10px 20px;
    margin: 5px 0;
    font-size: 1rem;
    cursor: pointer;
    border-radius: 6px;
  }
  #terminal {
    background: #000;
    width: 90%;
    max-width: 800px;
    height: 400px;
    padding: 15px;
    border-radius: 8px;
    border: 1px solid #333;
    overflow-y: auto;
    font-size: 1rem;
    line-height: 1.5;
    white-space: pre-wrap;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }
  #inputLine {
    width: 90%;
    background: transparent;
    border: none;
    color: #00ffae;
    font-family: "Fira Code", monospace;
    font-size: 1rem;
    outline: none;
  }
  .prompt {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    width: 90%;
    max-width: 800px;
    margin-top: 5px;
  }
  .prompt span {
    margin-right: 5px;
  }
</style>
</head>
<body>

<h1>Team Recursion - C Project</h1>

<div class="desc">
  <h3>Program 1 – Signals</h3>
  <p>This shows how parent and child processes communicate using signals.</p>
</div>

<select id="programSelector" onchange="changeProgram()">
  <option value="1">Program 1 – Signal Output</option>
  <option value="2">Program 2 – Buddy Allocator (Interactive)</option>
</select>

<button onclick="runProgram()">▶ Run Program</button>

<div id="terminal"></div>
<div class="prompt" id="promptContainer" style="display:none;">
  <span>&gt;</span>
  <input id="inputLine" type="text" autofocus autocomplete="off" />
</div>

<script>
const terminal = document.getElementById("terminal");
const inputLine = document.getElementById("inputLine");
const promptContainer = document.getElementById("promptContainer");
let program = 1;
let memory = Array(32).fill("FREE");
let runningBuddy = false;

function println(text) {
  terminal.innerText += text + "\n";
  terminal.scrollTop = terminal.scrollHeight;
}

function resetTerminal() {
  terminal.innerText = "";
}

function changeProgram() {
  program = document.getElementById("programSelector").value;
  resetTerminal();
  promptContainer.style.display = "none";
}

async function runProgram() {
  resetTerminal();
  if (program == 1) {
    let sampleOutput = [
      "[Parent] PID = 1024, created child with PID = 1025",
      "[Child] PID = 1025, waiting for signals...",
      "[Parent] Sending SIGUSR1...",
      "[Child] Received SIGUSR1 - Task 1 running",
      "[Parent] Sending SIGUSR2...",
      "[Child] Received SIGUSR2 - Task 2 running",
      "[Child] Exiting...",
      "[Parent] Communication completed."
    ];
    for (let line of sampleOutput) {
      println(line);
      await new Promise(r => setTimeout(r, 800));
    }
  } else {
    runningBuddy = true;
    memory = Array(32).fill("FREE");
    println("Buddy Memory Allocator Initialized (32 units)");
    println("Commands: alloc <size>, dealloc <addr>, status, exit");
    promptContainer.style.display = "flex";
    inputLine.focus();
  }
}

inputLine.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    const cmd = inputLine.value.trim();
    println("> " + cmd);
    handleCommand(cmd);
    inputLine.value = "";
  }
});

function handleCommand(cmd) {
  if (!runningBuddy) return;
  cmd = cmd.replace(/[<>]/g, "").trim(); // ✅ Fix: remove < >

  if (cmd.startsWith("alloc")) {
    const size = parseInt(cmd.split(" ")[1]);
    const idx = memory.indexOf("FREE");
    if (idx === -1) println("No block available");
    else {
      memory[idx] = "USED";
      println(`Allocated ${size} units at block ${idx}`);
    }
  } else if (cmd.startsWith("dealloc")) {
    const addr = parseInt(cmd.split(" ")[1]);
    if (!isNaN(addr) && memory[addr] === "USED") {
      memory[addr] = "FREE";
      println(`Deallocated block ${addr}`);
    } else {
      println("Invalid block or already free");
    }
  } else if (cmd === "status") {
    println("--- Memory Status ---");
    memory.forEach((b, i) => println(`Block ${i}: ${b}`));
  } else if (cmd === "exit") {
    println("Exiting Buddy Allocator...");
    promptContainer.style.display = "none";
    runningBuddy = false;
  } else {
    println("Unknown command. Try: alloc <size>, dealloc <addr>, status, exit");
  }
}
</script>

</body>
</html>

function changeProgram() {
  program = document.getElementById("programSelector").value;
  resetTerminal();
  promptContainer.style.display = "none";
}

async function runProgram() {
  resetTerminal();
  if (program == 1) {
    let sampleOutput = [
      "[Parent] PID = 1024, created child with PID = 1025",
      "[Child] PID = 1025, waiting for signals...",
      "[Parent] Sending SIGUSR1...",
      "[Child] Received SIGUSR1 - Task 1 running",
      "[Parent] Sending SIGUSR2...",
      "[Child] Received SIGUSR2 - Task 2 running",
      "[Child] Exiting...",
      "[Parent] Communication completed."
    ];
    for (let line of sampleOutput) {
      println(line);
      await new Promise(r => setTimeout(r, 800));
    }
  } else {
    runningBuddy = true;
    memory = Array(32).fill("FREE");
    println("Buddy Memory Allocator Initialized (32 units)");
    println("Commands: alloc <size>, dealloc <addr>, status, exit");
    promptContainer.style.display = "flex";
    inputLine.focus();
  }
}

inputLine.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    const cmd = inputLine.value.trim();
    println("> " + cmd);
    handleCommand(cmd);
    inputLine.value = "";
  }
});

function handleCommand(cmd) {
  if (!runningBuddy) return;
  cmd = cmd.replace(/[<>]/g, "").trim(); // ✅ Fix: remove < >

  if (cmd.startsWith("alloc")) {
    const size = parseInt(cmd.split(" ")[1]);
    const idx = memory.indexOf("FREE");
    if (idx === -1) println("No block available");
    else {
      memory[idx] = "USED";
      println(`Allocated ${size} units at block ${idx}`);
    }
  } else if (cmd.startsWith("dealloc")) {
    const addr = parseInt(cmd.split(" ")[1]);
    if (!isNaN(addr) && memory[addr] === "USED") {
      memory[addr] = "FREE";
      println(`Deallocated block ${addr}`);
    } else {
      println("Invalid block or already free");
    }
  } else if (cmd === "status") {
    println("--- Memory Status ---");
    memory.forEach((b, i) => println(`Block ${i}: ${b}`));
  } else if (cmd === "exit") {
    println("Exiting Buddy Allocator...");
    promptContainer.style.display = "none";
    runningBuddy = false;
  } else {
    println("Unknown command. Try: alloc <size>, dealloc <addr>, status, exit");
  }
}
</script>

</body>
</html>
